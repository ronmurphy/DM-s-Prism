import { GoogleGenAI, Type } from "@google/genai";
import { Character } from "../types";

// Helper to remove data URL prefix
const stripDataUrl = (dataUrl: string) => {
  return dataUrl.split(',')[1];
};

const getMimeType = (dataUrl: string) => {
    return dataUrl.substring(dataUrl.indexOf(':') + 1, dataUrl.indexOf(';'));
};

export const editMapImage = async (currentImageBase64: string, prompt: string): Promise<string> => {
  if (!process.env.API_KEY) {
    throw new Error("API Key not found");
  }

  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  
  const base64Data = stripDataUrl(currentImageBase64);
  const mimeType = getMimeType(currentImageBase64) || 'image/png';

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: {
        parts: [
          { inlineData: { mimeType: mimeType, data: base64Data } },
          { text: `Edit this TTRPG map image based on the following instruction. Maintain the top-down perspective and grid alignment if visible. Instruction: ${prompt}` }
        ]
      }
    });

    if (response.candidates && response.candidates[0].content.parts) {
        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData && part.inlineData.data) {
                return `data:image/png;base64,${part.inlineData.data}`;
            }
        }
    }
    
    throw new Error("No image generated by Gemini.");

  } catch (error) {
    console.error("Gemini Image Edit Error:", error);
    throw error;
  }
};

export const parseCharacterPdf = async (pdfBase64: string): Promise<Omit<Character, 'id' | 'avatarUrl' | 'ddbLink'>> => {
  if (!process.env.API_KEY) throw new Error("API Key not found");
  
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  const base64Data = stripDataUrl(pdfBase64);

  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash',
    contents: {
      parts: [
        { inlineData: { mimeType: 'application/pdf', data: base64Data } },
        { text: `You are an expert D&D 5e Rules Lawyer and Parser. Analyze this D&D Beyond Character Sheet PDF and extract the character details.

        Focus on these specific locations based on the standard D&D Beyond layout:
        1. **Name**: Top left, large bold text (e.g., "Holt").
        2. **Class & Level**: Top center-left row (e.g., "Paladin 5 / Monk 1"). Combine if multiclassed.
        3. **Level**: The total character level.
        4. **Ability Scores**: The vertical column on the far left. Return the SCORE (big number).
        5. **Max HP**: The box labeled "Max HP" (top right).
        6. **AC**: The shield icon labeled "ARMOR".
        7. **Speed**: The box labeled "Walking" or "Speed". Extract just the number (e.g., if it says "30 ft", return 30).

        Return a valid JSON object matching the schema.` }
      ]
    },
    config: {
      responseMimeType: 'application/json',
      responseSchema: {
        type: Type.OBJECT,
        properties: {
          name: { type: Type.STRING },
          class: { type: Type.STRING },
          level: { type: Type.INTEGER },
          maxHp: { type: Type.INTEGER },
          ac: { type: Type.INTEGER },
          speed: { type: Type.INTEGER },
          stats: {
            type: Type.OBJECT,
            properties: {
              str: { type: Type.INTEGER },
              dex: { type: Type.INTEGER },
              con: { type: Type.INTEGER },
              int: { type: Type.INTEGER },
              wis: { type: Type.INTEGER },
              cha: { type: Type.INTEGER },
            },
            required: ["str", "dex", "con", "int", "wis", "cha"]
          }
        },
        required: ["name", "class", "level", "maxHp", "ac", "speed", "stats"]
      }
    }
  });

  if (!response.text) throw new Error("Failed to extract character data");
  
  return JSON.parse(response.text);
};